############################
HOOKS IN FUNCTION COMPONENTS
#############################
I.	ABOUT
II.	USESTATE() HOOK
III.	STATE OBJECT SIMPLIFIED
#############################

#################
I.	ABOUT HOOKS
#################

Hooks are what allows us to manage or hook into a state inside a function components, something that wasn't possible before it's introduction in class components. Now basically all components are written as function components, and no longer as class components.

React provides a few built-in Hooks like useState and useEffect. You can also create your own Hooks to reuse stateful behavior between different components.


#####################
II.	USESTATE() HOOK
#####################

State and state changes are not native to a JS function. A react HOOK makes this possible.

The useState() takes in as an argument the STATE OBJECT wherein we define the key: value pairs. 

Note that the useState returns an ARRAY that contains our state(object) AND a function that allows us to SET our state.

To access both values in the array, use ARRAY DESTRUCTURING.

It is important to always use the setState() HOOK at top of the function, it cannot be inside an if statement, for example. This is because React is storing the initial state and state changes globally based on the order of the useState() calls you define at the top of the functions.

Import { useState } from 'react'

export default <fn name>({<prop-name>}){
	const [state, setState] = useState({ <key>: <value> })
	return(
		<jsx here>
		...
		<h1>{state.<key>}</h1>
	)
}

An example looks like this:

Note that in the onClick function we call the setState() function and pass in the key:value pair we want to update inside our state object.

To access the existing or initial value of a key, use state.<key>

export default function CounterHooks({ initialCount }){
    const [state, setState] = useState({ count: initialCount })
    return (
        <div>
            <button onClick={() => setState({count: state.count - 1})}>-</button>
            {/* <span>{props.initialCount}</span> */}
            {/*<span>{initialCount}</span>*/}
            <span>{state.count}</span>
            <button onClick={() => {setState({count: state.count + 1})}}>+</button>
        </div>
    )
}

ASYCN SETSTATE()

Here too, subsequent calls of the setState would be executed asynchronously. To amend this, here too use prevState:

<button onClick={() => {setState(prevState => {
	return {count: state.count + 1}})}}>+</button>


#############################
III.	STATE OBJECT SIMPLIFIED
#############################

In useState({key: value}) we can define the entire state object but this is a clunky to work with. You CAN use a simple VALUE as well. In this example, a number.

This greatly simplifies the code as you can modify the names STATE, SETSTATE and PREVSTATE to whatever you want, here: count(STATE), setCount(SETSTATE) and prevCount(PREVSTATE).

export default function CounterHooks({ initialCount }){
    const [count, setCount] = useState(initialCount)
    return (
        <div>
            <button onClick={() => setCount(prevCount => prevCount - 1)}>-</button>
            <span>{count}</span>
            <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>
 	)
}

This way we can break up our STATE into multiple variables instead of one object, which allows for simpler code. In CLASS components this is not possible and that's why function components are used much more frequently.
