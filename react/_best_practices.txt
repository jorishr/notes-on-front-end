#############
BEST PRACTICS
#############################################
A.	FILE STRUCTURE
B.	FUNCTIONAL COMPONENT FUNCTION STRUCTURE
C.	SMALL COMPONENTS
D.	NAMING
E. 	USING PROPS VS CONTEXT
F.	SEPERATION OF CONCERNS
G.	IMMUTABILITY
#############################################

A.	FILE STRUCTURE
Use a specific js file for each component (don't put multiple components in one file) and export them as the default. 

B.	FUNCTIONAL COMPONENT FUNCTION STRUCTURE
At the top define the various state, then the useEffect()

function App() {
//state defintions
  const [...] = useState();
  const [...] = useState(<defaultState>);
	...
//use effects
  useEffect(() => {}, [])
  useEffect(() => {}, [])
	....
//context api value
  const <contextVal> = { }
//handler functions
  function handleA() {}
  function handleB() {}
//return the jsx inside a provider
return (
    <<Context>.Provider value={<contextVal>}>
      <<Component prop={props} />
	<<ChildComponent prop={props} />}
    </<Context>.Provider>
)
}
const defaultStateValue = {key: val, key: val, key: [{}, {}]}

C.	SMALL COMPONENTS
Use as many components as you can. It may seem absurd to break down into atomic components but it makes the code easier to debug and easier to work with in the future.

Take a look at the data model you work with: Separate your UI into components, where each component matches one piece of your data model. The information architecture of the data model and the UI should be similar.

D.	NAMING
The 'handler' name in a function always leads to some kind of click event.

E. 	USING PROPS VS CONTEXT
Props are adequate for just one level nesting, from PARENT to CHILD. That is manageable. If go down deeper, you'll have to repeat the process of passing/destructuring. 

Also, you may have other section in the application with components that are not direcltly linked. Then use context.

Plus only define context in the major parts of you application, those components that have lots of children.

F.	SEPERATION OF CONCERNS
When writing useState() statements and useEffect() statements you could technically combine them all into the same object or same function respectively. However, it is better to seperate the different functionalities.

For example, one useEffect() for localStorage code, another for animation that have to be played.

useEffect(() =>{//localStorage},[])
useEffect(() =>{//play animation},[])

G.	IMMUTABILITY
Not being able to directly change the current Ingredients data objects (pros or state), for example. In react you have to make a copy, modify the copy and pass that to setSate() method, which triggers the update throughout the components.

Always work with the id of an object in state, apart from the object itself. If not you may be referencing the wrong thing throughout your app:

//state for editing: only id is required, it has no default state
const [selectedRecipeId, setSelectedRecipeId] = useState();
//default state for recipes-list is the sampleRecipes arr defined below
const [recipes, setRecipes] = useState(sampleRecipes) 

