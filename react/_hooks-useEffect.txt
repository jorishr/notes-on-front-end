#############
USEFFECT HOOK
##########################
I.	USE CASES AND SETUP
II.	LOCALSTORAGE EXAMPLE
III.	USEEFFECT() RETURN
##########################


#########################
I.	USE CASES AND SETUP
#########################

The Effect Hook, useEffect, adds the ability to perform side effects from a function component.

It serves the same purpose as componentDidMount, componentDidUpdate, and componentWillUnmount in React classes, but unified into a single API. 

Example is to PERSIST DATA by saving the application state in LocalStorage or DB and loading from it.

First, we need an additional action to happen each time the state of the app changes. This is accomplished by the useEffects() method.

import React, { useEffect } from 'react'

This method takes in a function (action to perform on state change) and an array of dependencies that specify which state changes need to trigger this additional action.

function App(){
	...
	useEffect(() => {do smth}, [dependency, ..., dependency])
}

Effects are declared inside the component so they have access to its props and state.

By default, React runs the effects after every render — including the first render.

##########################
II.	LOCALSTORAGE EXAMPLE
##########################

Store the current state in a localStorage item. Note, for the value of the key to be useful, convert it with JSON.stringify(value)

If you add another useEffect() whereby the dependencies are set to an empty array, the useEffect() will only run once, on page load.

const LOCAL_STORAGE_KEY = '<appName>.<appStateVar>'

function App(){
	...
	useEffect(() => {
		localStorage.setItem(LOCAL_STORAGE_KEY, appStateVar)}, 
	[appStateVar, ..., dependency])

useEffect(() => {
    const recipesJSON = 						localStorage.getItem(LOCAL_STORAGE_KEY)
    if(recipesJSON != null) 		{setRecipes(JSON.parse(recipesJSON))} 
  }, [])
}

Now if the page loads, and a localStorage key is found with recipe data, the app STATE is updated and set to the data that is parsed from the JSON object.

Important! Reverse the above order, first you need to use the useEffect with the getItem method, second the one with the setItem method.


########################
III.	USEEFFECT() RETURN
########################

The useEffect() can not only perform additonial actions upon state changes, it can also perform 'clean-up' action when the rendering of a component is done.

For example, each delete action updates the UI state of the app and but in the return statement of useEffect() we can define another function which will run each time a component unmounts. 

Thus when you delete a component, the return function is called from all the useEffect() methods that apply to it.

Note that the return function is called not only when you delete the component, but every single time AFTER the first time useEffect() is called. 

Thus from the second call onwards, first the return function is invoked. Followed by the regular useEffect code defined above it. This can be used to cleans things up before the useEffect is appled.





