###########################
INTERSECTIONAL OBSERVER API
#################################
I.	ABOUT
II.	HOW IT WORKS
III.	CHANGE NAV STYLES ON SCROLL
#################################

###########
I.	ABOUT
###########

The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's viewport.

Historically, detecting visibility of an element, or the relative visibility of two elements in relation to each other, has been a difficult task that caused performace issues.

The Intersection Observer API lets code register a callback function that is executed whenever an element they wish to monitor enters or exits another element (or the viewport), or when the amount by which the two intersect changes by a requested amount. 

This way, sites no longer need to do anything on the main thread to watch for this kind of element intersection, and the browser is free to optimize the management of intersections as it sees fit.

In short, an eventlistener is constantly running running code while the Observer allows for that code to run only when an intersection occurs.

##################
II.	HOW IT WORKS
##################

You initiate a new observer that takes in a callback fn and options.

	const observer = new IntersectionObserver(callback, options)

The callback function takes in the arguments ENTRIES and the observer itself.

	function(entries, observer) {
		entries.forEach(entry => {
			console.log(entry); 
			console.log(entry.target);}
	})

	const options = { 
		root: null,
		threshold: <0 to 1>,
		rootMargin: <>px		
	}
	
Root: null or {} means it is the viewport that is the point reference. 

Threshold: 1 means that 100% of the element that is being observed/monitored needs to be on the viewport, if not the callback will not run. At default zero, the slightest pixel of the element on the viewport will fire up the callback.

By adding a rootMargin you displace the reference up/down or left/right a number of pixels.

To call the method you created use:

	observer.observe(<elementYouWantToObserve>)

This element can be any DOM element you selected with the querySelector.


#################################
III.	CHANGE NAV STYLES ON SCROLL
#################################

The standard way of doing this is to add an EVENT LISTENER to the window and on scroll below a point (offsetTop) you add/remove a css class.

With the Intersectional Observer API you observe a section of the page. As it leaves the viewport, you add the css class. When it re-enters the viewport, you remove the class.

	const header = document.querySelector('header');
	const sectionOne = document.querySelector('.hero-section');

	const sectionOneOptions = {};
	const sectioOneObserver = 
		new IntersectionObserver(function(entries, 						sectionOneObserver){
				entries.forEach(entry => {
					console.log(entry.target);
					<WHAT TO DO>
				})
	}, 	sectionOneOptions);
	
	sectionOneObserver.observe(sectionOne);

The code that we want to run, is to ADD a css class when the hero section leaves the page, thus when it is no longer INTERSECTING with the page. In other words, when entry.intersecting is false.

	if(!entry.intersecting){
		header.classList.add('nav-scrolled');
	} else {header.classList.remove('nav-scrolled')};

To have this effect kick in before the section is scrolled of the page completely you can play with the rootMargin in the options.

	options {rootMargin: -200px 0px 0px 0px}; 

This will kick in the effect when the section 200px away from dissappearing from the page.