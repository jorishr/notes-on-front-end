CONTENTS
I.	ABOUT RESPOSIVE IMAGES
II.	IMAGE TYPES
III.	DIFFERENTLY CROPPED IMAGES FOR DIFFERENT SCREENS
IV.	SAME IMAGE, DIFFERENT IMAGE RESOLUTION
V.	COMBINE III and IV
VI.	FULL WIDTH vs SIZES
VII.	TESTING
VIII.	IMAGE PREPARATION
IX.	VIEWPORT DIMENSIONS
X.	GOOD TO KNOW


IMG URL 

In case we want to host our website at a URL that isn't at the root of a domain (e.g. username.github.io/travel-site vs username.github.io/) we'll want to change the way we reference background image files within our CSS.

This way your code works in a wider variety of hosting situations once you're ready to push the site live to the public.

background: url('/assets/images/testimonials-bg.jpg') top center no-repeat;

Use this:

background: url('assets/images/testimonials-bg.jpg') top center no-repeat;



ADD: 
- https://www.responsivebreakpoints.com/
- lazyloading+placeholders
	https://github.com/axe312ger/sqip
	https://www.guypo.com/introducing-lqip-low-quality-image-	placeholders
- content from images.txt

I. 	ABOUT RESPONSIVE IMAGES

Images have inherent dimensions. A 500px wide img will be pixelated when stretched beyond this size.

Thus, we have to take into account:
- img dimensions
- device dimensions,
- screen resolution

Responsive images in TWO situations:

(a) when cropping and art direction need to be adjusted for smaller/bigger screens,

(b) when image resolution and file size are important for fast loading times

Basically we are trying to solve TWO PROBLEMS: make images fit into mobile layouts while respecting their intrinsic size, and avoid making the user download unnecessarily large image files.

We accomplish (a) by making images always stretch to fill 100% of their container AND limiting the container size with an inline max-width style.

For (b), we use "srcset" to optimize for screen resolution,
srcset plus "sizes" to optimize for device width, and finally the <picture> element for full manual control over which image file is displayed.

NOTE: It is best to work with different sizes of the same image 
(high res, low res). So you let the browser decide which img to pick based on the device dimensions and resolution.

NOTE: Retina dislays have 2x or 3x the number of pixels per inch than standard displays and therefore need higher resolution images. Thus if you want a 500x250 image to display correctly it actually needs to be 1000x500.


II. IMAGE TYPES

SVG Images

These offers the easiest solution because they scale automatically.

IMPORTANT: 
- you need to set width:100% in CSS to scale them to their container.
- set the inline-style to it's standard MAX-WIDTH, if not it would scale too much on very big screens. style="max-width:500px"

GIF PNG and JPG

If you're not too concerned about image optimization you can just use a high res image, but they usually take up twice the amount of data.


III. DIFFERENTLY CROPPED IMAGES TO SMALL DEVICES

If the cropping of an image or the content of the picture does not display well on smaller/bigger screens then serve differently cropped images for each screen width. -> picture element

<picture>
  <source media='(min-width: 1200px)' 
	// screens > 1200px get adapted img
          srcset='images/photo-big.jpg'/>
  <source media='(min-width: 760px)'        
	// screens >760px get a special img
          srcset='images/photo-tall.jpg'/>
  <img src='images/photo-small.jpg' alt="description"/>      
	// fallback option
</picture>

IMPORTANT: the order of the code matters! From big to small!


IV. SAME CROPPED/ART IMG, DIFFERENT IMG RESOLUTIONS

Even if the img displays well artistically on all screens, there is no need to have small devices download high-res files. 

<img srcset="smallPic.jpg 570w, mediumPic.jpg 1200w, largePic 1920w" alt="desciption">

Now the browser will pick automatically which file has to be downloaded based on the screen it is working with. The choice of the browser is guided by the width we specified. 


V. COMBINE CROP/RES

<picture>
  <source media='(min-width: 1200px)'        
	// screens >1200px get adapted img
   	srcset='images/photo-big.jpg 1200w, 
			images/photo-big-hi-dpi.jpg 2400w'/>
  <source media='(min-width: 760px)'        
	// screens >760px get a special img
      srcset='images/photo-tall.jpg 760w, 
			images/photo-tall-hi-dpi.jpg 1520w'/>
  <img srcset='images/photo-small.jpg 480w, 
		images/photo-small-hi-dpi.jpg 960w' 						alt="description"/>      
	// fallback option
</picture>

NOTE: for the <img src=''> is swapped for srcset


VI.	FULL WIDTH vs SIZES

The browser will always assume that an image has to take up the full width of the screen and thus selects the image that is best suited for this purpose. 

However, if you work with images that do not take up all the page than you have to specify their maximum width with the SIZES property in the HTML.

<source	sizes="(max-width: 1000px) 100vw 1000px"
	   	srcset="imgLowDpi, imgHiDpi"
		media="(min-width:XXpx)">

https://cloudinary.com/blog/introducing_intelligent_responsive_image_breakpoints_solutions

VII. TESTING

- PLACEHOLDER FILES

Create copy with an -i added to the filename and insert the resolution into the image as written number. This ways it is easy to change the filenames in HTML, and to read on the screen which image is used by the browser.

- DEV TOOLS

Use the chrome dev tools for scaling and high-res testing.


VIII. IMAGE PREPARATION

Before you start your project you need various versions of each image. The dimension of each image will give a good indication about the media queries you have to use with them.

- large 1920w; large-hiRes 3840w  --media="(min-width: 1380px)"

- medium 1380w; medium hiRes 2760w --media="(min-width: 990px)"

- small 990w; small-hiREs 1980w --media="(min-width: 640px)"

- smallest 640w; smallest hiRes 1280w

Optional: -i files with dimension info.


IX. GOOD TO KNOW

PORTRAIT-MODE 

Big screen size width: 1920px, half of that 960px is a good width for content mobile in portrait-mode: <400px

While it is possible to combine the best of both worlds, it gets complicated real quick. Stick to the 1x and 2x version of srcset for images less than 600 pixels wide

- use the srcset plus sizes method from the previous section for bigger photos,
- and reserve <picture> for when youâ€™re trying to do something real fancy with your designer.

NOTE ABOUT INLINE VS BLOCK IMAGES

- by default the img are treated as inline elements. This means that it is treated as if were a line of text. All browser leave a basic gap between lines to acount for letters that hang out on the bottom, like "g".

- in galleries or when having a border on the container div, you may want to avoid this gap. Thus: display: block.

NOTE ABOUT FULL WIDTH vs NORMAL IMAGES

- the browser will automatically assume that the img needs to take up the full width of the screen. If this is NOT the case then you should indicate the width to the browser using the sizes="xxxpx" attribute! This way you also avoid the browser serving the hi-dpi version if not necessary.


